package interactor

import (
	"errors"
	"testing"

	"github.com/gity/point-system/entities"
	"github.com/gity/point-system/usecases/inputport"
	"github.com/gity/point-system/usecases/repository"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"gorm.io/gorm"
)

// ========================================
// Mock Implementations
// ========================================

type MockUserRepository struct {
	mock.Mock
}

func (m *MockUserRepository) Create(user *entities.User) error {
	args := m.Called(user)
	return args.Error(0)
}

func (m *MockUserRepository) Read(id uuid.UUID) (*entities.User, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.User), args.Error(1)
}

func (m *MockUserRepository) ReadByUsername(username string) (*entities.User, error) {
	args := m.Called(username)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.User), args.Error(1)
}

func (m *MockUserRepository) ReadByEmail(email string) (*entities.User, error) {
	args := m.Called(email)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.User), args.Error(1)
}

func (m *MockUserRepository) Update(user *entities.User) (bool, error) {
	args := m.Called(user)
	return args.Bool(0), args.Error(1)
}

func (m *MockUserRepository) UpdateBalanceWithLock(tx interface{}, userID uuid.UUID, amount int64, isDeduct bool) error {
	args := m.Called(tx, userID, amount, isDeduct)
	return args.Error(0)
}

func (m *MockUserRepository) UpdateBalancesWithLock(tx interface{}, updates []repository.BalanceUpdate) error {
	args := m.Called(tx, updates)
	return args.Error(0)
}

func (m *MockUserRepository) ReadList(offset, limit int) ([]*entities.User, error) {
	args := m.Called(offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.User), args.Error(1)
}

func (m *MockUserRepository) Count() (int64, error) {
	args := m.Called()
	return args.Get(0).(int64), args.Error(1)
}

func (m *MockUserRepository) Delete(id uuid.UUID) error {
	args := m.Called(id)
	return args.Error(0)
}

type MockTransactionRepository struct {
	mock.Mock
}

func (m *MockTransactionRepository) Create(tx interface{}, transaction *entities.Transaction) error {
	args := m.Called(tx, transaction)
	return args.Error(0)
}

func (m *MockTransactionRepository) Read(id uuid.UUID) (*entities.Transaction, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.Transaction), args.Error(1)
}

func (m *MockTransactionRepository) ReadByIdempotencyKey(key string) (*entities.Transaction, error) {
	args := m.Called(key)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.Transaction), args.Error(1)
}

func (m *MockTransactionRepository) ReadListByUserID(userID uuid.UUID, offset, limit int) ([]*entities.Transaction, error) {
	args := m.Called(userID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Transaction), args.Error(1)
}

func (m *MockTransactionRepository) ReadListAll(offset, limit int) ([]*entities.Transaction, error) {
	args := m.Called(offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Transaction), args.Error(1)
}

func (m *MockTransactionRepository) Update(tx interface{}, transaction *entities.Transaction) error {
	args := m.Called(tx, transaction)
	return args.Error(0)
}

func (m *MockTransactionRepository) CountByUserID(userID uuid.UUID) (int64, error) {
	args := m.Called(userID)
	return args.Get(0).(int64), args.Error(1)
}

type MockIdempotencyKeyRepository struct {
	mock.Mock
}

func (m *MockIdempotencyKeyRepository) Create(key *entities.IdempotencyKey) error {
	args := m.Called(key)
	return args.Error(0)
}

func (m *MockIdempotencyKeyRepository) ReadByKey(key string) (*entities.IdempotencyKey, error) {
	args := m.Called(key)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.IdempotencyKey), args.Error(1)
}

func (m *MockIdempotencyKeyRepository) Update(key *entities.IdempotencyKey) error {
	args := m.Called(key)
	return args.Error(0)
}

func (m *MockIdempotencyKeyRepository) DeleteExpired() error {
	args := m.Called()
	return args.Error(0)
}

type MockFriendshipRepository struct {
	mock.Mock
}

func (m *MockFriendshipRepository) Create(friendship *entities.Friendship) error {
	args := m.Called(friendship)
	return args.Error(0)
}

func (m *MockFriendshipRepository) Read(id uuid.UUID) (*entities.Friendship, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.Friendship), args.Error(1)
}

func (m *MockFriendshipRepository) ReadByUsers(userID1, userID2 uuid.UUID) (*entities.Friendship, error) {
	args := m.Called(userID1, userID2)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*entities.Friendship), args.Error(1)
}

func (m *MockFriendshipRepository) Update(friendship *entities.Friendship) error {
	args := m.Called(friendship)
	return args.Error(0)
}

func (m *MockFriendshipRepository) Delete(id uuid.UUID) error {
	args := m.Called(id)
	return args.Error(0)
}

func (m *MockFriendshipRepository) ReadListByUserID(userID uuid.UUID) ([]*entities.Friendship, error) {
	args := m.Called(userID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Friendship), args.Error(1)
}

func (m *MockFriendshipRepository) ReadPendingRequests(userID uuid.UUID) ([]*entities.Friendship, error) {
	args := m.Called(userID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Friendship), args.Error(1)
}

func (m *MockFriendshipRepository) CheckAreFriends(userID1, userID2 uuid.UUID) (bool, error) {
	args := m.Called(userID1, userID2)
	return args.Bool(0), args.Error(1)
}

func (m *MockFriendshipRepository) ReadListFriends(userID uuid.UUID, offset, limit int) ([]*entities.Friendship, error) {
	args := m.Called(userID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Friendship), args.Error(1)
}

func (m *MockFriendshipRepository) ReadListPendingRequests(userID uuid.UUID, offset, limit int) ([]*entities.Friendship, error) {
	args := m.Called(userID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entities.Friendship), args.Error(1)
}

type MockLogger struct {
	mock.Mock
}

func (m *MockLogger) Info(msg string, fields ...entities.Field) {
	m.Called(msg, fields)
}

func (m *MockLogger) Error(msg string, fields ...entities.Field) {
	m.Called(msg, fields)
}

func (m *MockLogger) Warn(msg string, fields ...entities.Field) {
	m.Called(msg, fields)
}

func (m *MockLogger) Debug(msg string, fields ...entities.Field) {
	m.Called(msg, fields)
}

func (m *MockLogger) Fatal(msg string, fields ...entities.Field) {
	m.Called(msg, fields)
}

// Mock DB Transaction (GORMのトランザクション処理を模倣)
type MockDB struct {
	mock.Mock
	shouldFail bool
}

func (m *MockDB) Transaction(fc func(tx *gorm.DB) error) error {
	// トランザクション内の処理を実行
	err := fc(nil) // nilを渡すが、実際にはモックされたRepositoryが動作する
	if m.shouldFail || err != nil {
		return err
	}
	return nil
}

// ========================================
// UseCase Tests (Point Transfer Interactor)
// ========================================

func TestPointTransferInteractor_Transfer_Success(t *testing.T) {
	// モックの準備
	mockUserRepo := new(MockUserRepository)
	mockTransactionRepo := new(MockTransactionRepository)
	mockIdempotencyRepo := new(MockIdempotencyKeyRepository)
	mockFriendshipRepo := new(MockFriendshipRepository)
	mockLogger := new(MockLogger)
	mockDB := &MockDB{shouldFail: false}

	// テストデータ
	fromUserID := uuid.New()
	toUserID := uuid.New()
	fromUser := &entities.User{
		ID:       fromUserID,
		Username: "sender",
		Balance:  5000,
		IsActive: true,
		Version:  1,
	}
	toUser := &entities.User{
		ID:       toUserID,
		Username: "receiver",
		Balance:  1000,
		IsActive: true,
		Version:  1,
	}

	// モックの期待値設定
	mockIdempotencyRepo.On("ReadByKey", "test-key").Return(nil, errors.New("not found"))
	mockIdempotencyRepo.On("Create", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockUserRepo.On("Read", fromUserID).Return(fromUser, nil)
	mockUserRepo.On("Read", toUserID).Return(toUser, nil)
	mockUserRepo.On("UpdateBalancesWithLock", mock.Anything, mock.AnythingOfType("[]repository.BalanceUpdate")).Return(nil)
	mockTransactionRepo.On("Create", mock.Anything, mock.AnythingOfType("*entities.Transaction")).Return(nil)
	mockTransactionRepo.On("Update", mock.Anything, mock.AnythingOfType("*entities.Transaction")).Return(nil)
	mockIdempotencyRepo.On("Update", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()

	// Interactorを作成
	interactor := &PointTransferInteractor{
		db:              mockDB,
		userRepo:        mockUserRepo,
		transactionRepo: mockTransactionRepo,
		idempotencyRepo: mockIdempotencyRepo,
		friendshipRepo:  mockFriendshipRepo,
		logger:          mockLogger,
	}

	// テスト実行
	req := &inputport.TransferRequest{
		FromUserID:     fromUserID,
		ToUserID:       toUserID,
		Amount:         2000,
		IdempotencyKey: "test-key",
		Description:    "Test transfer",
	}

	resp, err := interactor.Transfer(req)

	// 検証
	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.NotNil(t, resp.Transaction)
	assert.Equal(t, int64(2000), resp.Transaction.Amount)
	mockUserRepo.AssertExpectations(t)
	mockTransactionRepo.AssertExpectations(t)
	mockIdempotencyRepo.AssertExpectations(t)
}

func TestPointTransferInteractor_Transfer_SameUser(t *testing.T) {
	mockLogger := new(MockLogger)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()
	mockLogger.On("Error", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		logger: mockLogger,
	}

	userID := uuid.New()
	req := &inputport.TransferRequest{
		FromUserID:     userID,
		ToUserID:       userID,
		Amount:         1000,
		IdempotencyKey: "test-key",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.Error(t, err)
	assert.Nil(t, resp)
	assert.Contains(t, err.Error(), "cannot transfer to the same user")
}

func TestPointTransferInteractor_Transfer_InvalidAmount(t *testing.T) {
	mockLogger := new(MockLogger)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()
	mockLogger.On("Error", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		logger: mockLogger,
	}

	fromUserID := uuid.New()
	toUserID := uuid.New()

	testCases := []struct {
		name   string
		amount int64
	}{
		{"Zero amount", 0},
		{"Negative amount", -100},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := &inputport.TransferRequest{
				FromUserID:     fromUserID,
				ToUserID:       toUserID,
				Amount:         tc.amount,
				IdempotencyKey: "test-key",
				Description:    "Test",
			}

			resp, err := interactor.Transfer(req)

			require.Error(t, err)
			assert.Nil(t, resp)
			assert.Contains(t, err.Error(), "amount must be positive")
		})
	}
}

func TestPointTransferInteractor_Transfer_EmptyIdempotencyKey(t *testing.T) {
	mockLogger := new(MockLogger)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		logger: mockLogger,
	}

	req := &inputport.TransferRequest{
		FromUserID:     uuid.New(),
		ToUserID:       uuid.New(),
		Amount:         1000,
		IdempotencyKey: "",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.Error(t, err)
	assert.Nil(t, resp)
	assert.Contains(t, err.Error(), "idempotency key is required")
}

func TestPointTransferInteractor_Transfer_DuplicateIdempotencyKey_Completed(t *testing.T) {
	mockIdempotencyRepo := new(MockIdempotencyKeyRepository)
	mockTransactionRepo := new(MockTransactionRepository)
	mockUserRepo := new(MockUserRepository)
	mockLogger := new(MockLogger)

	fromUserID := uuid.New()
	toUserID := uuid.New()
	transactionID := uuid.New()

	existingKey := &entities.IdempotencyKey{
		Key:           "existing-key",
		Status:        "completed",
		TransactionID: &transactionID,
	}

	existingTransaction := &entities.Transaction{
		ID:     transactionID,
		Amount: 1000,
	}

	fromUser := &entities.User{ID: fromUserID, Balance: 3000}
	toUser := &entities.User{ID: toUserID, Balance: 2000}

	mockIdempotencyRepo.On("ReadByKey", "existing-key").Return(existingKey, nil)
	mockTransactionRepo.On("Read", transactionID).Return(existingTransaction, nil)
	mockUserRepo.On("Read", fromUserID).Return(fromUser, nil)
	mockUserRepo.On("Read", toUserID).Return(toUser, nil)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		userRepo:        mockUserRepo,
		transactionRepo: mockTransactionRepo,
		idempotencyRepo: mockIdempotencyRepo,
		logger:          mockLogger,
	}

	req := &inputport.TransferRequest{
		FromUserID:     fromUserID,
		ToUserID:       toUserID,
		Amount:         1000,
		IdempotencyKey: "existing-key",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Equal(t, existingTransaction, resp.Transaction)
	mockIdempotencyRepo.AssertExpectations(t)
	mockTransactionRepo.AssertExpectations(t)
}

func TestPointTransferInteractor_Transfer_DuplicateIdempotencyKey_Processing(t *testing.T) {
	mockIdempotencyRepo := new(MockIdempotencyKeyRepository)
	mockLogger := new(MockLogger)

	existingKey := &entities.IdempotencyKey{
		Key:    "processing-key",
		Status: "processing",
	}

	mockIdempotencyRepo.On("ReadByKey", "processing-key").Return(existingKey, nil)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		idempotencyRepo: mockIdempotencyRepo,
		logger:          mockLogger,
	}

	req := &inputport.TransferRequest{
		FromUserID:     uuid.New(),
		ToUserID:       uuid.New(),
		Amount:         1000,
		IdempotencyKey: "processing-key",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.Error(t, err)
	assert.Nil(t, resp)
	assert.Contains(t, err.Error(), "already in progress")
}

func TestPointTransferInteractor_Transfer_InsufficientBalance(t *testing.T) {
	mockUserRepo := new(MockUserRepository)
	mockIdempotencyRepo := new(MockIdempotencyKeyRepository)
	mockLogger := new(MockLogger)
	mockDB := &MockDB{shouldFail: false}

	fromUserID := uuid.New()
	toUserID := uuid.New()

	fromUser := &entities.User{
		ID:       fromUserID,
		Balance:  500, // 残高不足
		IsActive: true,
	}

	toUser := &entities.User{
		ID:       toUserID,
		Balance:  1000,
		IsActive: true,
	}

	mockIdempotencyRepo.On("ReadByKey", "test-key").Return(nil, errors.New("not found"))
	mockIdempotencyRepo.On("Create", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockUserRepo.On("Read", fromUserID).Return(fromUser, nil)
	mockUserRepo.On("Read", toUserID).Return(toUser, nil)
	mockUserRepo.On("UpdateBalanceWithLock", mock.Anything, fromUserID, int64(1000), true).
		Return(errors.New("insufficient balance"))
	mockIdempotencyRepo.On("Update", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()
	mockLogger.On("Error", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		db:              mockDB,
		userRepo:        mockUserRepo,
		idempotencyRepo: mockIdempotencyRepo,
		logger:          mockLogger,
	}

	req := &inputport.TransferRequest{
		FromUserID:     fromUserID,
		ToUserID:       toUserID,
		Amount:         1000,
		IdempotencyKey: "test-key",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.Error(t, err)
	assert.Nil(t, resp)
	assert.Contains(t, err.Error(), "insufficient balance")
}

func TestPointTransferInteractor_Transfer_InactiveUser(t *testing.T) {
	mockUserRepo := new(MockUserRepository)
	mockIdempotencyRepo := new(MockIdempotencyKeyRepository)
	mockLogger := new(MockLogger)
	mockDB := &MockDB{shouldFail: false}

	fromUserID := uuid.New()
	toUserID := uuid.New()

	fromUser := &entities.User{
		ID:       fromUserID,
		Balance:  5000,
		IsActive: false, // 無効なユーザー
	}

	toUser := &entities.User{
		ID:       toUserID,
		Balance:  1000,
		IsActive: true,
	}

	mockIdempotencyRepo.On("ReadByKey", "test-key").Return(nil, errors.New("not found"))
	mockIdempotencyRepo.On("Create", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockUserRepo.On("Read", fromUserID).Return(fromUser, nil)
	mockUserRepo.On("Read", toUserID).Return(toUser, nil)
	mockIdempotencyRepo.On("Update", mock.AnythingOfType("*entities.IdempotencyKey")).Return(nil)
	mockLogger.On("Info", mock.Anything, mock.Anything).Return()
	mockLogger.On("Error", mock.Anything, mock.Anything).Return()

	interactor := &PointTransferInteractor{
		db:              mockDB,
		userRepo:        mockUserRepo,
		idempotencyRepo: mockIdempotencyRepo,
		logger:          mockLogger,
	}

	req := &inputport.TransferRequest{
		FromUserID:     fromUserID,
		ToUserID:       toUserID,
		Amount:         1000,
		IdempotencyKey: "test-key",
		Description:    "Test",
	}

	resp, err := interactor.Transfer(req)

	require.Error(t, err)
	assert.Nil(t, resp)
	assert.Contains(t, err.Error(), "not active")
}

func TestPointTransferInteractor_GetBalance(t *testing.T) {
	mockUserRepo := new(MockUserRepository)

	userID := uuid.New()
	user := &entities.User{
		ID:      userID,
		Balance: 5000,
	}

	mockUserRepo.On("Read", userID).Return(user, nil)

	interactor := &PointTransferInteractor{
		userRepo: mockUserRepo,
	}

	req := &inputport.GetBalanceRequest{
		UserID: userID,
	}

	resp, err := interactor.GetBalance(req)

	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Equal(t, int64(5000), resp.Balance)
	assert.Equal(t, user, resp.User)
}

func TestPointTransferInteractor_GetTransactionHistory(t *testing.T) {
	mockTransactionRepo := new(MockTransactionRepository)

	userID := uuid.New()
	transactions := []*entities.Transaction{
		{ID: uuid.New(), Amount: 1000},
		{ID: uuid.New(), Amount: 2000},
	}

	mockTransactionRepo.On("ReadListByUserID", userID, 0, 10).Return(transactions, nil)
	mockTransactionRepo.On("CountByUserID", userID).Return(int64(2), nil)

	interactor := &PointTransferInteractor{
		transactionRepo: mockTransactionRepo,
	}

	req := &inputport.GetTransactionHistoryRequest{
		UserID: userID,
		Offset: 0,
		Limit:  10,
	}

	resp, err := interactor.GetTransactionHistory(req)

	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Len(t, resp.Transactions, 2)
	assert.Equal(t, int64(2), resp.Total)
}
